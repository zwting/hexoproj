{"meta":{"title":"有想法更要有行动","subtitle":"事在人为","description":"记录学习的点点滴滴","author":"zwting","url":"http://www.zuowting.top"},"pages":[{"title":"Tags","date":"2018-02-10T05:45:09.119Z","updated":"2018-02-10T05:45:09.119Z","comments":true,"path":"tags/index.html","permalink":"http://www.zuowting.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Unity3D特定文件的打开方式","slug":"Unity3D特定文件的打开方式","date":"2018-02-10T13:49:52.000Z","updated":"2018-02-10T14:03:25.720Z","comments":true,"path":"2018/Unity3D特定文件的打开方式.html","link":"","permalink":"http://www.zuowting.top/2018/Unity3D特定文件的打开方式.html","excerpt":"","text":"在Unity3D编辑器中，双击Shader文件默认的打开应用是和c#脚本一致，一般是Visual Studio。但是Visual Studio原生并没有提供对ShaderLab的语法支持。一般情况下都是用Sublime Text或者Visual Studio Code来作为Shader的编辑器。但是如果能够双击Shader文件直接打开对应的编辑器就再好不过了，后来知道Unity3D提供了编辑器扩展，允许我们监听文件双击打开的消息。是通过 UnityEdtitor.Callbacks 来实现的。具体见如下代码 1. 示例代码123456789101112131415161718192021222324252627using UnityEngine;using UnityEditor;using UnityEditor.Callbacks;using System.IO;public class FileopenHandler&#123; public static string sublimeTextPath = @\"D:\\Develop_Tools\\Sublime Text 3\\sublime_text.exe\"; [OnOpenAsset] public static bool OnOpenShaderFile(int instanceId, int line) &#123; if (EditorUtility.InstanceIDToObject(instanceId) is Shader) &#123; string assetPath = AssetDatabase.GetAssetPath(instanceId); string fullPath = Path.GetFullPath(assetPath); System.Diagnostics.Process process = new System.Diagnostics.Process(); System.Diagnostics.ProcessStartInfo startInfo = new System.Diagnostics.ProcessStartInfo(); startInfo.WindowStyle = System.Diagnostics.ProcessWindowStyle.Hidden; startInfo.FileName = sublimeTextPath; startInfo.Arguments = \"\\\"\" + fullPath + \"\\\"\"; process.StartInfo = startInfo; process.Start(); return true; &#125; return false; &#125;&#125; 2.解释说明以上代码关键部分在于[OnOpenAsset]这个属性。这里告诉Unity3D编辑器，当双击打开一个资源的时候执行下面这个函数。逻辑里面就通过参数实例ID拿到这个资源，判断如果是Shader类型的时候，就使用SublimeText编辑器来打开， 其中sublimeTextPath保存的是自己电脑上的Sublime路径。需要替换成自己电脑上的路径。","categories":[],"tags":[{"name":"Unity3D","slug":"Unity3D","permalink":"http://www.zuowting.top/tags/Unity3D/"}]},{"title":"[游戏编程模式]阅读笔记","slug":"游戏编程模式-阅读笔记","date":"2017-08-24T06:10:53.000Z","updated":"2018-02-09T11:43:09.636Z","comments":true,"path":"2017/游戏编程模式-阅读笔记.html","link":"","permalink":"http://www.zuowting.top/2017/游戏编程模式-阅读笔记.html","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Mathematics.for.3D.Game.Programming.and.Computer.Graphics阅读笔记(二)","slug":"mf3gpacg-2","date":"2017-08-24T06:08:28.000Z","updated":"2018-02-09T11:43:09.636Z","comments":true,"path":"2017/mf3gpacg-2.html","link":"","permalink":"http://www.zuowting.top/2017/mf3gpacg-2.html","excerpt":"","text":"第二章: 向量写在前面的话: 本文基本等同于翻译(加上自己的理解), 笔者英语水平有限, 难免会出现错误, 望高手在评论中指出, 谢谢!原书: Mathematics for 3D Game Programming and Computer Graphics, Third Edition 2.1 向量的属性 定义: 这里将向量定义为: 实数组成的n元组 不过大多数情况下, 这个n指的是2, 3, 4, 一个n维向量可以记为:$$V=(v_1,v_2,…,v_n) \\tag{2.1}$$$V_i$表示向量$V$的第i个分量, 通常情况下, 下标是这个分量所对应的坐标轴的名字. 例如: 一个三维向量$P$可以记为: $P_x,P_y,P_z$. 列向量: 可以使用1列n行来表示和(2.1)式等价的列向量$$V =\\begin{bmatrix}v_1\\\\ v_2\\\\ \\dots \\\\ v_n\\end{bmatrix} \\tag{2.2}$$ 行向量: 可以用1行n列来表示和(2.1)等价的行向量, 同时他也是列向量(2.2)的转置矩阵(行变列)$$V^T=\\begin{bmatrix}v_1 &amp; v_2 &amp; \\dots &amp; v_n\\end{bmatrix}\\tag{2.3}$$ 向量和标量相乘: 分别用这个标量和向量的每一个分量相乘, 结果是一个向量$$aV=Va=(av_1,av_2,\\dots,av_n) \\tag{2.4}$$ 向量和向量的加法: 每个分量分别相加, 结果是一个向量. 比如$P + Q$:$$P + Q = (p_1 + q_1,p_2 + q_2,\\dots,p_n + q_n)\\tag{2.5}$$ 向量和向量的减法: $P - Q$可以认为是$P + (-Q)$ 向量的运算法则: 给定任意两个标量$a,b$, 任意三个向量$P,Q,R$, 以下定律成立 (a). $P + Q = Q + P$(b). $(P + Q) + R = P + (Q + R)$(c). $(ab)P = a(bP)$(d). $a(P + Q) = aP + aQ$(e). $(a + b)P = aP + bP$ n维向量V的模是一个标量, 记做$\\left \\| V \\right \\|$, 计算公式如下:$$\\left \\| V \\right \\| = \\sqrt{\\sum_{i=1}^{n}V^2_i} \\tag{2.6}$$向量的模也可以叫做向量的长度. 长度为一的向量叫做unit vector(单位向量). 当$V$代表三维的点或者方向的时候, 公式(2.6)可以记作:$$\\left \\| V \\right \\| = \\sqrt{V_x^2 + V_y^2 + V_z^2}\\tag{2.7}$$一个向量$V$至少有一个分量不为0才能够被单位化, 做法就是用这个向量$V$乘以$\\frac{1}{\\left \\| V \\right \\|}$. 这个操作通常被称为normalization(单位化), 在3D图形学中应用的很广泛. 这里应该注意的就是单位化这儿术语和normal vector(法向量)这个术语并没有什么联系, 法向量指的平面中垂直于这个平面的一个向量. 向量的模遵循以下定律: 定理2.2 给定一个标量$a$, 任意两个向量$P, Q$.(a). $\\left \\| P \\right \\| \\geq 0$(b). $P = 0 当且仅当 P = (0,0,\\dots,0)$(c). $\\left \\| aP \\right \\| =\\left |a\\right | \\left \\| P \\right \\|$(d). $\\left \\| P + Q \\right \\| \\leqslant \\left \\|P \\right \\| \\left \\|Q \\right \\|$ 2.2 向量的点乘向量的点乘, 通常也叫做scalar product(数量积) or inner product(內积), 在3D图形学中用的很广泛因为他可以衡量两个向量的方向相似程度 向量的点乘法则: n维向量$P, Q$的內积记作: $P \\cdot Q$, 通过下面的公式来计算$$P \\cdot Q = \\sum^{n}_{i=1}P_iQ_i \\tag{2.9}$$其实就是两个向量对应分量的乘积的和. 在三维空间中, 有如下公式:$$P\\cdot Q = P_xQ_x + P_yQ_y + P_zQ_z \\tag{2.10}$$点乘$P \\cdot Q$也可以表达为两个矩阵相乘:$$P^TQ = \\begin{bmatrix}P_1 &amp; P_2 &amp; \\cdots &amp; P_n\\end{bmatrix}\\begin{bmatrix}Q_1 \\\\ Q_2 \\\\ \\vdots \\\\ Q_n\\end{bmatrix} \\tag{2.11}$$最终的结果是一个1X1的矩阵(可以认为它是一个标量), 这正式公式(2.9)的运算结果.下面来看一个点乘的很常见的应用: 定理2.4 给定两个n维向量$P,Q$, 点乘$P \\cdot Q$等于下面的公式$$P \\cdot Q = \\left \\|P \\right \\| \\left \\|Q \\right \\| \\cos \\alpha \\tag{2.12}$$$\\alpha $是从原点到$P,Q$表示的两点的连线的夹角 点乘结果的符号表明两个向量在平面的同一侧或者不同侧, 如图2.3 点乘的另外一个功能就是可以表示两个向量方向的相似程度. 再次看图2.3, 我们可以认为有一个平面通过向量$P$的起点, 并且垂直于向量$P$. 任何和向量$P$在同一侧的向量和$P$的点乘结果都是正数, 任何在平面另一侧的向量和$P$的点乘结果是负数.下面还有一些点乘的性质: 定理2.5 给定任意一个标量$a$ 和任意三个向量$P,Q,R$, 下面性质成立.(a). $P \\cdot Q = Q \\cdot P$(b). $(aP) \\cdot = a(P \\cdot Q)$(c). $P \\cdot (Q + R) = P \\cdot Q + P \\cdot R$(d). $P \\cdot P = \\left \\|P \\right \\|^2$(e). $\\left | P \\cdot Q \\right | \\leqslant \\left \\|P \\right \\| \\left \\|Q \\right \\|$ 向量点乘的另一个应用场景就是分解向量$P$的分量, 得到垂直或者平行于另外一个向量$Q$的分量. 就像在图2.4所展示的一样, 如果我们将向量$P$看做是一个直角三角形的斜边, 然后将向量$P$在垂直于向量$Q$的方向上投影, 将会产生一条直角边. 在向量$P$和$Q$之间的夹角为$\\alpha$由三角学我们可以得知: $\\alpha$的邻边的长度为$\\left \\|P \\right \\| \\cos \\alpha$, 从定理2.4我们可以得知: 不知道角度$\\alpha$同样可以获取它的长度:$$\\left \\|P \\right \\| \\cos \\alpha = \\frac{P \\cdot Q}{\\left \\| Q \\right \\|}\\tag{2.17}$$为了获取到一个长度和它一样的平行于$Q$的向量,可以用公式(2.7)的右边乘以$Q$的单位向量$\\frac{Q}{\\left \\|Q \\right \\|}$. 我们用下面的公式来得到$P$在$Q$方向上的投影向量$proj_QP$:$$proj_QP = \\frac{P \\cdot Q}{\\left \\|Q \\right \\|^2}Q\\tag{2.18}$$ 向量$P$在向量$Q$上的投影向量的长度等于$\\frac{P \\cdot Q}{\\left \\| Q \\right \\|}$是因为$P \\cdot Q = \\left \\| P \\right \\| \\left \\|Q \\right \\| \\cos \\alpha$.","categories":[],"tags":[{"name":"OpenGL, 图形学","slug":"OpenGL-图形学","permalink":"http://www.zuowting.top/tags/OpenGL-图形学/"}]},{"title":"Mathematics.for.3D.Game.Programming.and.Computer.Graphics阅读笔记(一)","slug":"mf3gpacg_1","date":"2017-08-24T06:08:28.000Z","updated":"2018-02-09T11:43:09.636Z","comments":true,"path":"2017/mf3gpacg_1.html","link":"","permalink":"http://www.zuowting.top/2017/mf3gpacg_1.html","excerpt":"","text":"第一章: 渲染管线写在前面的话: 本文基本等同于翻译(加上自己的理解), 笔者英语水平有限, 难免会出现错误, 望高手在评论中指出, 谢谢!原书: Mathematics for 3D Game Programming and Computer Graphics, Third Edition 一. 渲染管线1.1 图形处理器一个3D图形场景通常包含了很多独立的对象.这些对象的几何形式通常是由一些特定类型的图元组成的.图元指的是顶点以怎样的方式连接构成了这种形状. 图1.1列出了 OpenGL图形库定义了10种图元. 图形硬件可以渲染一系列独立的点, 一些线段, 或者一组已经填充好了的多边形. 在大多数情况下, 3D模型的表面是由一些\u001b三角形构成的, 每一个三角形又是由顶点列表中的3个顶点组成. 现代的3D图形\b卡通常会执行从CPU发出的一些指令, CPU想GPU发出渲染命令, 然后CPU会执行其他的任务, 而GPU会执行这些渲染操作. 这通常被称为异步操作. 当需要被渲染的图形信息被提交到渲染库(OpenGL等)的时候, 请求渲染操作的函数将会在渲染操作还未完成前很早就返回. 这些在一个渲染命令的子操作和渲染完成之间的滞后时间将不会产生什么问题, 但是在渲染完成的时刻是需要知道的. 幸运的是, 目前OpenGL的一些扩展可程序以在CPU中运行, 这些程序能够在GPU完成渲染的时候发出通知.但同时会带来性能损耗, 这种异步操作会拖慢3D图形程序的执行速度, 因此, 如果想要性能优先, 那么应该避免这些操作. 那么应用程序和GPU的通信是怎么来进行呢? 通常是通过一些第三方的图形库来实现的, 比如OpenGL. 这些应用将会通过调用OpenGL API方式来向其发出渲染命令. 而OpenGL等图形库又向GPU驱动程序发送渲染命令, 这些驱动程序才知道怎样和GPU交流. OpenGL的这些接口我们称之为Hardware Abstraction Layer(HAL) 硬件抽象层, 因为它提供了一些通用的函数可以用来渲染场景, 这些函数可以在任何支持OpenGL架构的图形硬件上运行. 驱动程序将会把这些OpenGL的API转换成GPU可以执行的命令. 3D图形驱动程序通常会直接实现OpenGL函数以最小化渲染命令的开销. 图1.2 展示了CPU和GPU之间的通信过程: 一个3D图形卡有自己的存储空间(显存), 通常被称为VRAM (Video Random Access Memory). GPU可以在VRAM中存储任何东西, 当时在3D应用程序运行的时候, 有这么几类数据大多数总可以在显存中找到. VRAM中有两个图像缓冲区, 被称为前缓冲和后缓冲 (传说中的双缓冲). 其中, front image buffers 包含了当前在可视区域内看到的每一个像素的数据. 可视区域 指的就是包含了已经被渲染的图象数据的一个区域, 他可能是一个窗口, 也可能是整个屏幕; back image buffer是GPU真正渲染的场景的位置. back buffer 在渲染完成呈现给用户之前是不可见的. 一旦一个图像完成了渲染, back buffer 和 front buffer 将会交换数据. 这个操作被称为缓冲交换. 他可以通过以下几种方式来实现: 直接交换两个缓冲区的内存地址 将back buffer中的数据拷贝到fornt buffer中 缓冲区交换通常和图像显示刷新率保持同步, 这是为了避免发生画面撕裂现象. 画面撕裂通常由于在刷新期间发生了缓冲区交换, 这将会导致一副图像的上半部分和下半部分不同, 因为他们的数据分别来自front buffer和back buffer. 还有一块存储在VRAM中的数据块被称为Depth-buffer或者z-buffer. 深度缓冲存储的数据是图像缓冲中的每一个像素数据的depth,depth表明这个像素距离屏幕有多远或者这个像素位于图像中的哪个深度. 深度缓冲通常用来隐藏或表面消除的功能, 它只绘制深度小于图像缓冲去深度的像素. Depth同时也表明了从被绘制的场景到虚拟相机(充当人眼的那个位置)的距离. 而z-buffer这个名字来自于相机的Z轴, 它是从相机的坐标空间射向屏幕的方向.随着image buffer和depth buffer的创建, 应用程序可能会请求stencil buffer(模板缓冲区). stencil buffer包含了一个整型的遮罩, 这和image buffer中的每一个像素都是一一对应的, 他可以用来控制特定的像素是否被绘制. 更高级的stencil buffer可以用来产生实时阴影.大多数3D渲染应用程序中使用VRAM主要通过Texture maps(纹理贴图), texture maps通常被用来附着到物体的表面以达到更好的视觉细节. 在高级渲染程序中, texture maps通常包含了比简单像素图像更多的信息. 例如: 一个bump map(凹凸贴图)包含的信息是一个个的向量, 这些向量表明了物体表面对应位置的倾斜程度. 1.2 向量变换几何数据以3维空间的形式传给了图形硬件. 接下来图形硬件需要做的就是就是将这些数据转换到2维空间的视口内. 在rendering pipeline(渲染管线) 过程中有很多与之相关联的坐标系统, 他们之间的转换过程如图1.3. 一个3D 模型的顶点通常存储在对象的object space(模型坐标空间)内, 这个坐标系统取决于特定的模型.每一个模型的位置通常被存储在word space(世界坐标空间)中, 这个坐标空间将所有的对象连接到一个全局的坐标空间中. 在每一个对象被渲染之前, 它的顶点必须被转换到camera space(相机空间)中, 这个坐标空间的x和y轴适合显示区域的x和y平行的. 模型的顶点是可以直接从模型空间转换到相机空间的,具体做法就是通过矩阵乘法将 模型坐标-&gt;世界坐标的变换矩阵Mobj-word 和 世界坐标-&gt;相机坐标的变换矩阵Mword-camera 连接起来,得到Mobj-camera称之为 model-view变换.一旦模型的顶点被转换到了相机空间,他们会经历一个投影变换, 这个变换将会达到人眼视觉系统近大远小的视觉效果. 这个投影是通过四维空间其次坐标来完成的, 在这些顶点完成投影后的坐标空间被称为homogeneous clip space(齐次裁剪空间), 之所以这么叫它, 是因为在这个坐标空间,图元会被裁剪在可视区域内,确保落在可视区域外面的图元不会被渲染. 在齐次坐标空间中, 每个顶点的坐标称为normalized device coordinates(规格化设备坐标, 简称NDC), 这里出现了一个新的术语normalized(规格化或标准化), 它的意思其实就是将每个顶点的x,y,z分量映射到[-1,1]区间内, 它表示顶点最终出现在视口中的位置. 顶点还要经历再一次的变换viewport transformation(视口变换), 这个变换的结果其实就是最终顶点呈现在屏幕上的位置, z分量通常会被映射到[-1,1]区间内, 但是随后它会被缩放到深度缓冲所使用的每一个像素位对应的整型范围.最后, 顶点呈现在了我们的屏幕上.除了从模型空间转换到屏幕空间外, 图形处理器还会针对每一个顶点做一些运算.例如: OpenGL的光照模型将会计算到达每一个顶点的光照强度的该顶点反射颜色以及最终会有多少颜色会被反射进入人眼(相机的位置). 这中运算被称为per-vertex lighting(逐顶点光照). 一些高级的3D程序会使用逐顶点光照处理, 这将会在物体表面产生很细腻的光照表现(像素级别的).每一个顶点还会携带一个甚至更多的texture coordinates(纹理坐标). 通常情况下, 纹理坐标是由应用程序明确指定的或者是GPU自动生成的. 图元在渲染的时候, 将会根据纹理坐标从对应的纹理中查询到对应的颜色值插入到图元对应的位置. 这些颜色和其他在每个像素被插入的颜色将会决定最终在视口中的显示效果. 1.3 光栅化和片元操作一旦模型的顶点完成了坐标转换最终呈现在了屏幕中, GPU必须决定这些在视口中的像素应该用什么样的图元来呈现. 水平扫描固定间隔的像素填充图元的处理过程叫做raserization(光栅化). GPU计算每一个像素的深度, 插入顶点颜色和纹理坐标. 这些信息和像素本身的位置结合起来叫做fragment(片元).图元到片元的转换如图1.4. 应用程序必须在这个过程的第一阶段决定是否进行face culling(表面剔除).表面剔除只会对多边形图元生效, 它会移除背对着相机或者面对着相机的多边形图元. 但是大多数情况下,表面剔除被用来优化性能, 因为它会去除背对着相机的多边形, 这些不需要被渲染, 因为我们看不到它. 图形应用程序指定片元数据在光栅化过程中怎样来确实每一个像素的最终颜色和深度. 这个过程叫做fragment shading 或者 pixel shading(片元着色). 最终的颜可可能是从纹理获取来的颜色和顶点插入的颜色的成绩, 也可能是复杂的逐顶点光照的结果. 最终的深度通常不会变化, 但是一些高级的3D图形硬件允许我们来按照自己的意愿替换最终计算的深度值. 图1.5展示了在光栅化过程中每一个片元产生所执行的操作. 大部分操作都会决定一个图元最终绘制到屏幕上或者被丢弃. 从逻辑上来讲,虽然这些操作会在片元着色之后再进行, 但大多数GPU会在执行片元着色前进行一些测试, 这些测试能够带来一些性能和时间上的优势: 有一些最终根本不会被显示到屏幕上的图元将不会通过测试, 这就节省了不必要的性能开销和时间开销.","categories":[],"tags":[{"name":"OpenGL, 图形学","slug":"OpenGL-图形学","permalink":"http://www.zuowting.top/tags/OpenGL-图形学/"}]},{"title":"Git学习","slug":"Git学习","date":"2017-07-28T05:20:24.000Z","updated":"2018-02-09T11:43:09.636Z","comments":true,"path":"2017/Git学习.html","link":"","permalink":"http://www.zuowting.top/2017/Git学习.html","excerpt":"","text":"一. 初始化 初始化当前目录为一个git仓库: git init 设置git账户: 12git config --global user.name &quot;You Name&quot;git config --global user.email &quot;your email address&quot; 二. 仓库操作1. 版本管理 添加文件到暂存区: git add [Files] 将暂存区的文件提交: git commit -m [&#39;msg&#39;] 2. 指定不纳入版本管理的文件: 在git仓库下打开.gitignore文件(Mac/Linux系统下这个文件是个隐藏的, 可以在终端中用命令调用文本编辑器来打开vim .gitignore), 顾名思义, 这个文件名字告诉我们就是用来忽略掉在版本管理中我们不关心的文件, 具体用法如下: 在git中, 每一行代表一个用来匹配的模式 空行不会匹配任何模式, 因此可以用来当做分割线使得.gitignore文件看起来更美观 以#开头的是一个注释 尾部的空格将会被忽略掉, 除非他们用反斜杠 “\\” 括起来 前缀”!” 代表一个取反的操作: 会消除前一个模式中指定的忽略的文件. 例如\\*.swp!lib.swp这个模式代表将会忽略掉不是以lib.swp结尾的所有.swp文件6.(…未完) 3.查看仓库状 可以查看\b工作区状态: git status 4. 仓库的创建 克隆一个远端仓库到指定的目录中: git clone [&#39;url&#39;] 克隆一个远端仓库到已存在的目录中: git clone [&#39;url&#39;] [&#39;path&#39;] 5. 操作 删除在工作区删除了但版本库里面尚未删除的文件: git rm [文件名] 只从暂存区删除而不从工作区删除文件: git rm --cached [文件名] 例如: deleteme.rb添加到了暂存区, 现在不想让它被暂存, 就可以使用这条命令:git rm --cached deleteme.rb 6. git stash命令 解释: 当你想清空当前的工作目录的时候, 可以使用git stash命令来记录当前的工作目录和暂存区的状态. 这个命令可以保存你的本地修改并且将你的工作目录恢复到和HEAD commit一致的状态 简而言之: 就是可以既更新版本库的最新版本, 又可以保存本地的修改(纯属个人理解) git stash list: 列出已经备份过的改变 git stash show: 显示已经记录在stash中的文件状态和它的原始状态的不同 git stash save: 将本地的修改作为一个新的stash, 并且重置工作目录(git stash命令也会被解析为git stash save) 7. git mv命令 解释: 从暂存区中移除已跟踪的文件或重命名已跟踪的文件","categories":[],"tags":[{"name":"工具;版本管理","slug":"工具-版本管理","permalink":"http://www.zuowting.top/tags/工具-版本管理/"}]},{"title":"OpenGL学习笔记(一)--window下VS2013环境搭建OpenGL开发环境","slug":"OpenGL-Learn-1","date":"2017-05-29T08:05:00.000Z","updated":"2018-02-09T11:43:09.636Z","comments":true,"path":"2017/OpenGL-Learn-1.html","link":"","permalink":"http://www.zuowting.top/2017/OpenGL-Learn-1.html","excerpt":"","text":"1. 环境搭建 需要: Win10; VS2013(其他版本的VS未经测试, 但总体流程和操作相差不大); GLFW3(windows 32位版本); GLEW 新建C++项目 首先使用VS2013新建一个C++的控制台项目OpenGL_Lean, 然后打开生成解决方案(可自己先新建一个main.cpp, 写上main函数,后面会用到) GLEW和GLFW安装步骤: 1. 分别解压glfw和glew得到两个文件夹 glfw解压后文件夹结构如下图 (图1.1) glew文件夹结构 (图1.2) 2. 复制库文件和头文件首先找到VS2013的安装目录 (如果是默认安装, 那么应该在C:\\Program Files (x86)\\Microsoft Visual Studio 12.0) 第一步: 复制动态库文件:分别复制glew (bin\\Release\\Win32\\glew32.dll) 和glfw (lib-vc2013\\glfw3.dll) 这两个DLL文件到第一步新建的项目的OpenGL_Learn里面的Debug文件夹下(也可以直接复制到c:\\windows\\system32下), 复制完成后如下图: 第二步: 复制静态库文件:分别复制glew(lib\\Release\\glew32s.lib) 和glfw (lib-vc2013\\glfw3.lib)这两个lib文件到[VS2013安装目录]\\vc\\lib下面 第三步: 复制头文件:分别复制glew: include\\GL和glfw: include\\GLFW文件夹到[VS2013安装目录]\\vc\\include. 复制完成之后VS2013的vc\\include文件夹应该是这样的 3. 在VS2013中设置依赖库打开VS的解决方案资源管理器, 在刚才的项目上右键, 点击属性打开属性设置对话框, 如下图然后按照上图展开链接器&gt;输入, 在项目依赖库里面填入glfw3.lib;glew32s.lib两个静态库, 如上图所示 4. 设置项目类型(显示控制台或者不显示) 显示控制台窗口: 个人在开发阶段喜欢同时显示控制台窗口, 因为这样可以看到标准输入输出信息, 方便调试和排查错误. 打开方式: 无需特殊打开, 默认如此 不显示控制台窗口: 只显示OpenGL图形窗口 打开方式: 依次打开属性","categories":[],"tags":[{"name":"OpenGL, 图形学","slug":"OpenGL-图形学","permalink":"http://www.zuowting.top/tags/OpenGL-图形学/"}]}]}